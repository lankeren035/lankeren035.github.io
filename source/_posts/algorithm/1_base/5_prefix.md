---
title: 1-5 前缀和与差分

date: 2024-6-2

tags: [算法，差分]

categories: [算法]

comment: false

toc: true
---

#

<!--more-->

# 5 前缀和与差分

## 5.1 一维区间和

- 输入一个长度为 n 的整数序列。接下来再输入 m 个询问，每个询问输入一对 l,r。对于每个询问，输出原序列中从第 l个数到第 r个数的和。

- 输入格式

  - 第一行包含两个整数 n和 m。

  - 第二行包含 n个整数，表示整数数列。
  - 接下来 m行，每行包含两个整数 l和 r，表示一个询问的区间范围。

-  输出格式：共 m行，每行输出一个询问的结果。

- 数据范围
  - 1≤l≤r≤n
  - 1≤n,m≤100000
  - −1000≤数列中元素的值≤1000

- 输入样例：

    ```
    5 3
    2 1 3 6 4
    1 2
    1 3
    2 4
    ```

- 输出样例：

    ```
    3
    6
    10
    ```

### 5.1.1 模板

```c++
#include<iostream>
using namespace std;

const int N=100000;
int a[N]={0},s[N]={0};

int main(){
    int n,m;
    //ios::sync_with_stdio(false); //可以加快cin，但还是没有scanf快
    scanf("%d%d",&n,&m); //输入规模比较大时使用scanf更快
    for(int i=1; i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++) s[i] = s[i-1] + a[i]; //前缀和初始化
    
    while(m--){
        int l,r;
        scanf("%d%d",&l,&r);
        printf("%d\n",s[r]-s[l-1]); //计算区间和
    }
    
    return 0;
}
```



## 5.2 二维区间和

- 输入一个 n行 m列的整数矩阵，再输入 q个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。

- 输入格式

  - 第一行包含三个整数 n，m，q。

  - 接下来 n行，每行包含 m个整数，表示整数矩阵。

  - 接下来 q行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。

- 输出格式：共 q行，每行输出一个询问的结果。

- 数据范围
  - 1≤n,m≤1000,
  - 1≤q≤200000,
  - 1≤x1≤x2≤n,
  - 1≤y1≤y2≤m,
  - −1000≤矩阵内元素的值≤1000

- 输入样例：

    ```
    3 4 3
    1 7 2 4
    3 6 2 8
    2 1 2 3
    1 1 2 2
    2 1 3 4
    1 3 3 4
    ```

- 输出样例：

    ```
    17
    27
    21
    ```



### 5.2.1 思想

- 画矩形分块：
  - $S_ { x _ 1 y _ 1 - x_ 2 y_ 2 } = S_ { x_ 2 y_ 2 } - S_ { x_ 2 (y_ 1-1) } - S_ { (x_ 1-1) y_ 2 }+ S_ { (x_ 1-1)(y_ 1 -1) }$
  - $S_ {ij} = S_ { (i-1)j } + S_ { i(j-1) }-S_ { (i-1)(j-1) } + a_ { ij }$

### 5.2.2 模板

```c++
#include<iostream>
using namespace std;

const int N=1001;
int s[N][N];

int main(){
    int m,n,q,x,y;
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            {
                scanf("%d",&s[i][j]);
                //+=省去了a[i][j]
                s[i][j] += s[i-1][j]+s[i][j-1]-s[i-1][j-1];
            }
            
    while(q--){
        scanf("%d%d%d%d",&m,&n,&x,&y);
        cout<<s[x][y]-s[x][n-1]-s[m-1][y]+s[m-1][n-1]<<endl;
    }
    return 0;
}
```



## 5.3 差分

- 已知：
  - $a_ 1,a_ 2 \ldots , a_ n$
- 求：
  - $b_ 1, b_ 2, \ldots,b_ n$
  - 要求：$b_ i = a_ i - a_ { i-1 }$
- $a$是$b$的前缀和
- 差分的作用：假设你需要将从$a_m$到 $a_ n$之间的数全都加上一个常熟C，在$a$上操作需要$O(n)$；而在$b$上操作只需要将$b_ m+C$和$b_ {n-1}-C$就可以了，这样只需要$O(1)$

### 5.3.1 题目

- 输入一个长度为 n的整数序列。接下来输入 m个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r][𝑙,𝑟] 之间的每个数加上 c。请你输出进行完所有操作后的序列。

- 输入格式

  - 第一行包含两个整数 n 和 m。

  - 第二行包含 n个整数，表示整数序列。

  - 接下来 m行，每行包含三个整数 l，r，c，表示一个操作。

- 输出格式
  
- 共一行，包含 n个整数，表示最终序列。
  
- 数据范围
  - 1≤n,m≤100000,
  - 1≤l≤r≤n,
  - −1000≤c≤1000,
  - −1000≤整数序列中元素的值≤1000

-  输入样例：

    ```
    6 3
    1 2 2 1 2 1
    1 3 1
    3 5 1
    1 6 1
    ```

-  输出样例：

    ```
    3 4 5 3 4 2
    ```

### 5.3.2 思想

- 根据a构建b：
    ```
    //假设b是a的差分
    b[i] += a[i] //b[i]加一次相当于把后面所有a都加了偏移
    b[i+1] -= a[i] //将后面的偏移全部减掉，a不变，假设依然成立
    ```

### 5.3.3 模板

```c++
#include<iostream>
using namespace std;

const int N= 100010;
int a[N],b[N];

void insert(int l, int r, int c){
    b[l]+=c;
    b[r+1]-=c;
}

int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    //a
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    
    //b
    for(int i=1;i<=n;i++) insert(i,i,a[i]);
    
    while(m--){
        int l,r,c;
        scanf("%d%d%d",&l,&r,&c);
        insert(l,r,c);
    }
    
    //b->a
    for(int i=1;i<=n;i++) b[i]+=b[i-1];
    
    for(int i=1;i<=n;i++) printf("%d ",b[i]);
    
    return 0;
}
```



## 5.4 差分矩阵

- 输入一个 n行 m列的整数矩阵，再输入 q个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1)和 (x2,y2)表示一个子矩阵的左上角坐标和右下角坐标。每个操作都要将选中的子矩阵中的每个元素的值加上 c。请你将进行完所有操作后的矩阵输出。

- 输入格式

  - 第一行包含整数 n,m,q。

  - 接下来 n行，每行包含 m个整数，表示整数矩阵。

  - 接下来 q行，每行包含 5个整数 x1,y1,x2,y2,c，表示一个操作。

- 输出格式
  
- 共 n行，每行 m个整数，表示所有操作进行完毕后的最终矩阵。
  
- 数据范围
  - 1≤n,m≤1000,
  - 1≤q≤100000,
    1≤x1≤x2≤n,
  - 1≤y1≤y2≤m,
  - −1000≤c≤1000,
  - −1000≤矩阵内元素的值≤1000

- 输入样例：

    ```
    3 4 3
    1 2 2 1
    3 2 2 1
    1 1 1 1
    1 1 2 2 1
    1 3 2 3 2
    3 1 3 4 1
    ```

- 输出样例：

    ```
    2 3 4 1
    4 3 4 1
    2 2 2 2
    ```

### 5.4.1 思想

- 令b=0，画出矩阵区域得到计算一个$b_ {ij}$的方法：

  $b_ {x_ 1 y_ 1} += c$

  $b_ { (x_ 2+1) y_ 1} -= c$

  $b_ { x_ 1 (y_ 2 +1)} -= c$

  $b_ { (x_ 2+1) (y_ 2 +1)} += c$

### 5.4.2 模板

```c++
#include<iostream>
using namespace std;

const int N = 1010;
int a[N][N], b[N][N];

void insert(int x1, int y1, int x2, int y2, int c){
    b[x1][y1] += c;
    b[x2+1][y1] -= c;
    b[x1][y2+1] -= c;
    b[x2+1][y2+1] += c;
}

int main(){
    int n,m,q;
    cin>>n>>m>>q;
    //a
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d",&a[i][j]);
            
    //b
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            insert(i,j,i,j,a[i][j]);
            
    while(q--){
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        //对b操作
        insert(x1,y1,x2,y2,c);
    }
    
    //b->a
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)
            cout<<(b[i][j] += b[i-1][j]+b[i][j-1]-b[i-1][j-1])<<' '; 
        cout<<'\n';
    }

            
    return 0;
}
```

