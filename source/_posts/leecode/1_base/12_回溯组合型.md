---
title: "回溯组合型"
date: 2026-2-7 13:00:00
tags: [刷题]
categories: [刷题]
comment: true
toc: true


---

#

<!--more-->





## 1. 组合

> -  给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。  你可以按 **任何顺序** 返回答案。 
>
> - ```
>   输入：n = 4, k = 2
>   输出：
>   [
>     [2,4],
>     [3,4],
>     [2,3],
>     [1,2],
>     [1,3],
>     [1,4],
>   ]
>   ```

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        def dfs(i):
            d = k - len(path)
            if len(path) == k:
                res.append(path.copy())
                return
            for j in range(i,d-1,-1):
                path.append(j)
                dfs(j-1)
                path.pop()
        res = []
        path = []
        dfs(n)
        return res
```

## 2. 组合总合III

> -  找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件： 
>
>   - 只使用数字1到9
>   - 每个数字 **最多使用一次** 
>   -  返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 
>
> - ```
>   输入: k = 3, n = 7
>   输出: [[1,2,4]]
>   解释:
>   1 + 2 + 4 = 7
>   没有其他符合的组合了。
>   ```

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        def dfs(i, t):
            d = k - len(path)
            if t<0 or t > (i+(i-d+1)) * d / 2:
                return
            if len(path) == k:
                res.append(path.copy())
                return
            for j in range(i,d-1,-1):
                path.append(j)
                dfs(j-1, t-j)
                path.pop()

        res = []
        path = []
        dfs(9,n)
        return res
```

## 3. 括号生成

> -  数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。 
>
> - ```
>   输入：n = 3
>   输出：["((()))","(()())","(())()","()(())","()()()"]
>   ```

```python'
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        def dfs(i,open):
            if i == n*2:
                res.append(''.join(path))
                return 
            if open < n:
                path[i] = '('
                dfs(i+1,open+1)
            if i - open < open:
                path[i] = ')'
                dfs(i+1,open)

        res = []
        path = [''] * (n*2)
        dfs(0,0)
        return res
```

