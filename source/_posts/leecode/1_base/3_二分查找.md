---
title: "二分查找"
date: 2026-1-27 10:00:00
tags: [刷题]
categories: [刷题]
comment: true
toc: true





---

#

<!--more-->



## 1. 排序数组中查找元素的第一个和最后一个位置

-  给你一个按照非递减顺序排列的整数数组 `nums` ，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 ，返回 `[-1, -1]`。  你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。 

- ```
  输入：nums = [5,7,7,8,8,10], target = 8
  输出：[3,4]
  ```
```

```

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        res=[-1,-1] #start为第一个>=targe的数，end为第一个>=target+1的数的位置-1
        res[0] = self.lowerbound3(nums,target)
        # 如果查找不到
        if res[0] >= len(nums) or nums[res[0]] != target:
            return [-1,-1]
        res[-1] = self.lowerbound3(nums,target+1) - 1
        return res
    def lowerbound1(self, nums: List[int], target: int) -> List[int]: #闭区间
        left,right=0,len(nums)-1
        while left<=right:
            mid = left + (right - left) //2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left
    def lowerbound2(self, nums: List[int], target: int) -> List[int]: #左闭右开
        left,right=0,len(nums)
        while left<right: #区间不为空，left<right
            mid = left + (right - left) //2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left
    def lowerbound3(self, nums: List[int], target: int) -> List[int]: #开区间
        left,right=-1,len(nums)
        while left+1<right:
            mid = left + (right - left) //2
            if nums[mid] < target:
                left = mid
            else:
                right = mid
        return right
```



## 2. 寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。 你可以假设 `nums[-1] = nums[n] = -∞` 。  你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。 

- ```
  输入：nums = [1,2,1,3,5,6,4]
  输出：1 或 5 
  解释：你的函数可以返回索引 1，其峰值元素为 2；
       或者返回索引 5， 其峰值元素为 6。
  ```

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        left,right=0,len(nums)-2
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid]<nums[mid+1]:
                left = mid+1
            else:
                right = mid-1
        return left
```



## 3. 寻找旋转排序数组中的最小值

 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：  若旋转 `4` 次，  则可以得到 `[4,5,6,7,0,1,2]` 。 若旋转 `7` 次，  则可以得到 `[0,1,2,4,5,6,7]` 

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left,right=0,len(nums)-2
        while left<=right:
            mid = left + (right-left) //2
            if nums[mid]<nums[-1]:
                right=mid-1
            else:
                left = mid + 1
        return nums[left]
```



## 4. 搜索旋转排序数组

 整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。  在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **向左旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 下标 `3` 上向左旋转后可能变为 `[4,5,6,7,0,1,2]` 。  给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。 

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left,right = 0,len(nums)-1
        while left<=right:
            mid = left+(right-left)//2
            if nums[mid] <= nums[-1]: #mid在右侧
                if target<= nums[-1]: #target在右侧
                    if nums[mid] < target:
                        left = mid + 1
                    else:
                        right = mid -1
                else: #target在左侧
                    right = mid - 1

            else: #mid在左侧
                if target<= nums[-1]: # target在右侧
                    left = mid + 1
                else:
                    if nums[mid] < target:
                        left = mid + 1
                    else:
                        right = mid -1
        if left==len(nums) or nums[left] != target:
            return -1
        else:
            return left
        
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def isblue(i):
            end = nums[-1]
            if nums[i] > end: #mid在左边
                return target > end and nums[i]>=target   #target也在左边，且target偏左，需要right移动
            else: #mid在右边
                return target > end or nums[i] >= target #target在左需要right移动，  target在右且偏左，需要right移动
        left,right = 0,len(nums)-1
        while left<=right:
            mid = left+(right-left)//2
            if isblue(mid):
                right = mid -1
            else:
                left = mid + 1
        if left == len(nums) or nums[left] != target:
            return -1
        else:
            return left
```

