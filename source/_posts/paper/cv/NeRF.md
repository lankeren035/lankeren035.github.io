---
title:  "神经辐射场（Neural Radiance Fields，NeRF）"

date:  2025-4-14 15:28:00

tags:  [cv]

categories:  [cv]

comment:  false

toc:  true

---


#

<!--more-->

- 参考：https://blog.csdn.net/qq_44324007/article/details/129998545
- https://zhuanlan.zhihu.com/p/599994753
- https://www.bilibili.com/video/BV1pN4y1y7tk?spm_id_from=333.788.videopod.sections&vd_source=3988165c7848b1c4da919fec04b512a5

# 简介

- 神经辐射场（Neural Radiance Fields，简称NeRF）是一种计算机视觉技术，用于生成高质量的三维重建模型。它利用深度学习技术**从多个视角的图像中提取出对象的几何形状和纹理信息，然后使用这些信息生成一个连续的三维辐射场，从而可以在任意角度和距离下呈现出高度逼真的三维模型**。NeRF技术在计算机图形学、虚拟现实、增强现实等领域有着广泛的应用前景。

  > - 辐射场（Radiance Field）描述了光的传播行为。在三维空间中，对于任意一条光线（即起点和方向），场景中的每个点都可以计算出该光线在该点的辐射度。对于每个点，辐射场可以用一个颜色值和一个辐射度值来表示。颜色值指的是该点的表面颜色，而辐射度值指的是该点在光照下的明暗程度。通过在整个三维场景中计算光线的辐射度，可以生成高质量的渲染图像。
  > - 在NeRF中，辐射场的概念被扩展为在三维空间中对于任意一条光线，计算场景中的每个点在该光线方向上的颜色和密度。因此，NeRF的辐射场可以用来表示三维场景中的物体表面颜色和密度信息。利用这些信息，可以在任意角度和距离下呈现出高度逼真的三维模型。

# 输入输出

- **输入**：多个视角的图像和相机参数（包括相机位置和方向）。

- **输出**：连续的三维辐射场，表示三维场景中每个点的颜色和密度的函数。

  >- 点的密度：在计算机图形学中，点的密度通常指的是在一个给定的区域内，所包含的点的数量。例如，如果我们有一个场景，需要对其进行渲染，我们可以将场景分成多个小区域，并计算每个区域内的点的密度。如果一个区域内的点的密度较高，说明在该区域内有更多的几何细节，需要更高的采样率来捕捉细节；相反，如果一个区域内的点的密度较低，说明在该区域内的几何结构相对简单，需要较低的采样率来捕捉几何信息。
  >- 在 NeRF 中，点的密度也是一个很重要的概念。我们希望在渲染图像时能够在场景中均匀地采样点，以捕捉更全面的几何信息。因此，在训练 NeRF 模型时，我们需要对场景进行采样，并尽可能地让采样点的密度均匀。通常情况下，我们会在场景中随机生成一些点，并根据相机位置和方向，计算每个点的可见性，并将可见的点用于训练模型。在这个过程中，我们需要权衡采样点的数量和密度，以获得最佳的结果。

# 优缺点

- **优点**：生成的三维模型质量高、逼真度高，可以在任意角度和距离下呈现出真实的物体表面和纹理细节。此外，它可以从任意数量的输入图像中生成三维模型，而不需要对输入进行特定处理或标记。
- **缺点**：需要大量的计算资源和时间进行训练，且难以处理大规模的场景和复杂的光照条件。此外，由于NeRF是基于视图合成的技术，因此在生成模型时需要确保输入的视角足够广泛和充分，否则可能会导致模型中存在遮挡和空洞。

# 原理

- NeRF技术通过将输入的多个视角的图像和相机参数组合起来，建立一个多层感知机（MLP）模型来表示场景中每个点的颜色和密度。

- 在训练阶段，NeRF使用图像渲染技术将生成的三维场景渲染为二维图像，并与真实图像进行对比，以优化模型参数。NeRF模型的关键在于如何表示场景中每个点的颜色和密度。

- 为此，NeRF使用了一种称为体积渲染（volume rendering）的技术。体积渲染将三维空间分成许多小的体素（voxel），并对每个体素中的颜色和密度进行插值。通过对所有体素进行插值，可以得到整个场景的颜色和密度值。

  >- 体积渲染是一种将 3D 数据（例如医学图像、CT 扫描、地质勘探数据等）转换成可视化图像的技术。在 3D 数据中，每个像素不仅包含颜色信息，还包含了各种物理量信息，如密度、温度、速度等。体积渲染技术可以将这些物理量信息可视化出来，使得人们可以更好地理解和分析 3D 数据。
  >
  >- 体积渲染的核心思想是在 3D 数据中对每个像素进行采样，并根据每个采样点的物理量信息计算其颜色和透明度。具体来说，我们可以将 3D 数据表示为一个**体积纹理**，然后使用光线追踪算法在体积纹理中采样点，计算每个采样点的颜色和透明度，并将其合成成最终的图像。
  >
  >- 在 NeRF 中，体积渲染技术被用于将 3D 场景转换成可视化图像。我们可以将 3D 场景表示为一个密集的点云，并使用 NeRF 模型预测每个点的颜色和透明度。然后，在渲染图像时，我们可以使用体积渲染技术在点云中进行采样，计算每个采样点的颜色和透明度，并将其合成成最终的图像。这样就可以将 3D 场景可视化成 2D 图像，使得人们可以更好地理解和分析场景中的几何和光学信息。

  >- 体积纹理（volume texture）是指一种将三维图像数据储存在三维纹理（3D texture）中的技术，可以实现在三维空间中对体积数据进行快速渲染和操作。
  >
  >- 通常情况下，体积纹理是由离散的体素（volumetric pixel）组成的，每个体素代表三维空间中的一个小立方体。每个体素储存了该立方体内的物理量信息，例如密度、颜色、纹理等。通过对体素数据进行插值，可以在三维空间中生成连续的体积数据，从而实现渲染效果。
  >
  >- 体积纹理常被应用于医学图像处理、计算机辅助设计、仿真等领域。在nerf中，体积纹理用于储存场景中的密度信息和颜色信息，从而实现对场景的渲染。

# 结构

- NeRF的实现结构包括两个主要组件：编码器（encoder）和解码器（decoder）。
  - **编码器**：通常由卷积神经网络（CNN）组成，负责从输入的多个视角图像和相机参数中提取出场景中每个点的空间位置和视角特征。编码器中的每个卷积层都可以将输入数据从低维空间映射到高维空间，并提取出更复杂的特征表示。
  - **解码器**：通常由多层感知机（MLP）组成，负责从编码器提取的特征中生成连续的三维辐射场。具体来说，解码器接受来自编码器的每个点的空间位置和视角特征作为输入，并输出该点的颜色和密度值。解码器中的每个MLP层都可以将输入数据映射到另一个高维空间，并提取出更复杂的特征表示。

- 在训练阶段，NeRF使用一组二维图像和相应的相机参数作为输入，并使用**渲染方程**将输入数据转换为三维场景。*渲染方程用于计算从相机位置和方向发出的光线与场景中对象的相交点*，并确定每个点的颜色和密度值。然后，NeRF使用神经网络逼近渲染方程，以最小化生成场景与真实图像之间的差异。

  >在 NeRF 的训练阶段，模型需要学习到每个场景中每个点的颜色和透明度。为了实现这个目标，NeRF 引入了渲染方程（Rendering Equation），用于描述从相机到场景中某个点的光线经过的路径上所有光线与物体之间相互作用的物理规律。
  >
  >渲染方程是计算机图形学中的一个重要概念，它描述了光线从相机出发穿过场景中各种材质的路径，最终到达像素的过程，并计算出该像素的颜色值。渲染方程通常表示为一个积分方程，其中包含场景中的各种光线传播和交互的物理过程。
  >
  >渲染方程的核心是在积分符号下的反射模型，它描述了从一个点反射出去的光线的分布规律，通常也被称为 BRDF（双向反射分布函数）。BRDF 描述了在某个点上，入射光线的方向和出射光线的方向之间的关系，并且取决于物体的材质和表面状态。
  >
  >渲染方程的计算过程分为两个阶段：第一个阶段是求解相机射线与场景中物体的交点；第二个阶段是计算渲染方程的积分式。在第一个阶段，需要使用光线追踪算法计算相机射线与场景中的物体的交点，并确定该光线在场景中的传播路径。在第二个阶段，需要计算在该交点处的光线颜色和亮度，并将其与所有从其他方向发出的光线的颜色和亮度相加，得到最终的渲染结果。
  >
  >对于 NeRF 模型来说，在训练阶段，需要根据渲染方程对模型进行优化，使其能够生成与真实场景尽可能相似的图像。在测试阶段，需要使用渲染方程对相机从不同角度拍摄的场景进行渲染，得到高质量的 3D 渲染图像。
  >
  >在训练阶段，我们的目标是通过最小化真实图像与渲染图像之间的差异，来优化神经网络中的权重。因此，渲染方程在训练阶段主要用于生成渲染图像，计算渲染图像和真实图像之间的误差，从而优化神经网络。
  >

# pytorch实现

## 1）第三方库进行 NeRF 的实现

```shel
pip install nerf-pytorch
```

```python
import torch
import nerf

model = nerf.models.NeRF()

x = torch.randn(10, 3)  # 10 samples with 3 features each
y = model(x)
print(y.shape)  # output shape: (10, 4)
```

- 这里我们生成了一个包含 10 个样本的输入数据 x，每个样本都有 3 个特征。我们将输入数据输入到 model 中，并将输出结果 y 打印出来。可以看到，输出结果 y 的形状是 (10, 4)，其中第一维表示有 10 个样本，第二维表示有 4 个特征。在 NeRF 中，最后一维通常用于表示颜色或者透明度等信息。

## 2）自行实现

```python
import torch
from torch import nn
from torch.nn import functional as F

class NeRF(nn.Module):
    def __init__(self, input_dims, output_dims, hidden_dims=256, num_layers=8):
        super().__init__()
        self.input_dims = input_dims
        self.output_dims = output_dims

        # MLP layers
        layers = []
        for i in range(num_layers):
            layers.append(nn.Linear(input_dims, hidden_dims))
            layers.append(nn.ReLU(inplace=True))
            input_dims = hidden_dims
        layers.append(nn.Linear(hidden_dims, output_dims))
        self.mlp = nn.Sequential(*layers)

    def forward(self, x):
        x = self.mlp(x)
        return x
model = NeRF(input_dims=3, output_dims=3)
x = torch.randn(10, 3)
y = model(x)
print(y.shape)  # (10, 3)
```

- 这里定义了一个名为 NeRF 的 PyTorch 模型类，该类接受一个输入维度 input_dims、输出维度 output_dims、隐藏层维度 hidden_dims 和层数 num_layers 等参数。在初始化函数中，我们定义了一个包含多个线性层和 ReLU 激活函数的 MLP 模型。在前向传播函数中，我们使用 MLP 模型对输入数据 x 进行处理，并将输出返回。


